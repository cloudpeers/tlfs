//! # The local first sdk's crdt
//!
//! ## ORSet
//! The workhorse of this crate is an ORSet (Observed-Remove Set). An ORSet has a store set and
//! an expired set. When an element is added it is added to the store set. When it's removed it's
//! removed from the store and added to the expired set.
//!
//! ## Path
//! The elements stored in this ORSet are called paths. These paths are used to represent other
//! crdts like the EWFlag, MVReg, ORMap and ORArray. The path has the following logical format:
//! ```bnf
//! prim := prim_bool | prim_u64 | prim_i64 | prim_str
//! key := prim
//! field := prim_str
//! ewflag := peer nonce
//! mvreg := peer nonce prim
//! gpolicy := peer policy
//! path := doc (key | field)* (ewflag | mvreg | gpolicy)
//! ```
//!
//! ## Case study: Using ORSet<Path> to construct an MVReg
//! An MVReg is a set of concurrently written values. When a value is assigned all previous
//! values are cleared. To create an ORSet that performs an MVReg assign when joined with
//! another ORSet we add each value currently in the MVReg to the expired set and add the new
//! value to the store set. When this delta is joined with the previous state, or with other
//! concurrent updates the set of values will converge.
//!
//! NOTE: peer identifiers in paths are for declaring authorship and verifying signatures. they
//! are not required for convergence.
//!
//! ## Byzantine Eventual Consistency
//! In distributed systems without coordination only some properties are achivable. The strongest
//! properties that a distributed system without coordination can achive is called BEC. BEC has
//! the following properties that are guaranteed in the presence of an arbitrary number of byzantine
//! nodes assuming that correct replicas form a connected component:
//!
//! - self-update: If a correct replica generates an update, it applies that update to its own
//! state.
//! - eventual update: For any update applied by a correct replica all correct replicas will
//! eventually apply that update
//! - convergence: Any two correct replicas that have applied the same set of updates are in the
//! same state
//! - atomicity: When a correct replica applies an update, it atomically applies all the updates
//! resulting from the same transaction.
//! - authenticity: If a correct replica applies an update that is labeled as originating from
//! replica s, then that update was generated by replica s
//! - causal consistency: if a correct replica generates or applies update u1 before generating
//! update u2, then all correct replicas apply u1 before u2.
//! - invariant preservation: The state of a correct replica always satisfies all of the
//! application's declared invariants.
//!
//! ## Invariant confluence
//! A set of transactions can be executed without coordination if and only if those transactions
//! are I-confluent with regard to all of the application's invariants.
//!
//! Transaction T is I-confluent with regard to invariant I if for all Ti,Tj,S where Ti and Tj are
//! concurrent and the state S, `Si = apply(Ti, S)` and `Sj = apply(Tj, S)` satisfy I implies that
//! `apply(Tj, apply(Ti, S))` also satisfies I.
//!
//! ## Access control
//!
//! ## Schemas and transforms
//!
//! ## Future improvements
//! - compromise recovery: recover from accidental or malicious modification to restore a previous
//! state.
//! - using untrusted servers: currently the ORSet converges even when the paths are encrypted.
//! However for correct operation we need to also prove that encrypted updates don't violate the
//! invariants and that the author had permission to make the change. Also Homomorphic transforms
//! that preserve the zero knowledge proofs will be required.
mod acl;
mod crdt;
mod crypto;
mod cursor;
mod doc;
mod dotset;
mod id;
mod lens;
mod path;
#[cfg(test)]
mod props;
mod registry;
mod schema;
mod subscriber;
mod util;

pub use crate::acl::{Permission, Policy};
pub use crate::crdt::{Causal, CausalContext};
pub use crate::crypto::{
    ArchivedEncrypted, ArchivedSigned, Encrypted, Key, KeyNonce, Keypair, Signed,
};
pub use crate::cursor::Cursor;
pub use crate::doc::{Backend, Doc, Frontend};
pub use crate::dotset::{AbstractDotSet, Dot, DotSet};
pub use crate::id::{DocId, PeerId};
pub use crate::lens::{ArchivedKind, ArchivedLens, ArchivedLenses, Kind, Lens, LensRef, Lenses};
pub use crate::path::{Path, PathBuf, Segment};
pub use crate::registry::{Hash, Registry, EMPTY_HASH, EMPTY_LENSES, EMPTY_SCHEMA};
pub use crate::schema::{ArchivedSchema, PrimitiveKind, Prop, Schema};
pub use crate::subscriber::{Event, Subscriber};
pub use crate::util::Ref;
